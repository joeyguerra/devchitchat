# PROTOCOL.md — hubot-chat-p2p

This document defines the **WebSocket control-plane protocol** between browser clients and the Hubot (Node) server.

Goals:
- Explicit, versioned message shapes
- Minimal dependencies (hand-rolled validation OK)
- Secure-by-default (no implicit trust, no over-posting)
- “Make things visible” (trace IDs, consistent errors)

Non-goals:
- Media transport (audio/video/screen) — that happens via WebRTC P2P
- End-to-end encryption (E2EE) — v0 is transport-secure; E2EE is a vNext

---

## Transport

- **WebSocket** (`wss://.../ws`)
- All messages are UTF-8 JSON objects.
- Client MUST send `hello` immediately after connect.
- Server responds with `hello_ack` or `error` then may close connection.

---

## Envelope

Every message MUST have:

```json
{
  "v": 1,
  "t": "message_type",
  "id": "client-generated-id",
  "ts": 1730000000000,
  "trace": "optional-trace-id",
  "body": {}
}
```

## Fields:
- v (number): protocol version (v0 = 1)
- t (string): message type
- id (string): unique message ID generated by sender (UUID-ish). Used for acking and debugging.
- ts (number): epoch millis when sender created message
- trace (string, optional): correlation ID (server may set if absent)
- body (object): message payload; type-specific

## Server-to-client may include:
- ok (boolean): true for successful replies/events
- reply_to (string): original message id this responds to
- server_ts (number): server epoch millis
- sid (string): server connection/session ID (for observability)

## Error model
Server sends:
```json
{
  "v": 1,
  "t": "error",
  "id": "server-msg-id",
  "reply_to": "original-id-if-any",
  "ts": 1730000000000,
  "server_ts": 1730000000123,
  "body": {
    "code": "AUTH_REQUIRED",
    "message": "Human readable summary",
    "details": { "field": "invite_token" }
  }
}
```

### Common code values:
- BAD_REQUEST
- UNSUPPORTED_VERSION
- AUTH_REQUIRED
- AUTH_FAILED
- FORBIDDEN
- NOT_FOUND
- CONFLICT
- RATE_LIMITED
- INTERNAL

## Authentication & sessions
hello (client → server)

Sent immediately on connect.

```json
{
  "v": 1,
  "t": "hello",
  "id": "c1",
  "ts": 1730000000000,
  "body": {
    "client": {
      "name": "hubot-chat-p2p-web",
      "ver": "0.1.0",
      "platform": "browser",
      "ua": "optional user agent"
    },
    "resume": {
      "session_token": "optional"
    }
  }
}
```

hello_ack (server → client)

```json
{
  "v": 1,
  "t": "hello_ack",
  "id": "s1",
  "reply_to": "c1",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "server": { "name": "hubot-chat-p2p", "ver": "0.1.0" },
    "session": {
      "authenticated": false,
      "user": null,
      "session_token": null
    },
    "limits": {
      "max_rooms": 200,
      "max_group_members": 20,
      "max_message_bytes": 8000,
      "max_signaling_bytes": 64000
    }
  }
}
```
auth.invite_redeem (client → server)

Redeem one-time invite (expires; default 24h). Creates user + session.

```json
{
  "v": 1,
  "t": "auth.invite_redeem",
  "id": "c2",
  "ts": 1730000001000,
  "body": {
    "invite_token": "string",
    "profile": {
      "handle": "joey",
      "display_name": "Joey"
    }
  }
}
```

auth.session (server → client)
Server returns session token (or sets secure cookie; but protocol supports token for simplicity).

```json
{
  "v": 1,
  "t": "auth.session",
  "id": "s2",
  "reply_to": "c2",
  "ok": true,
  "server_ts": 1730000001123,
  "body": {
    "session_token": "string",
    "user": {
      "user_id": "u_123",
      "handle": "joey",
      "display_name": "Joey",
      "roles": ["user"]
    }
  }
}
```

auth.logout (client → server)
```json
{
  "v": 1,
  "t": "auth.logout",
  "id": "c3",
  "ts": 1730000002000,
  "body": {}
}
```

## Presence

Presence is a projection, not authoritative truth.

presence.subscribe (client → server)

```json
{
  "v": 1,
  "t": "presence.subscribe",
  "id": "c10",
  "ts": 1730000000000,
  "body": {
    "scope": "server" 
  }
}
```

scope:
- server (all known users; small group)
- room (presence events only for a room)

presence.snapshot (server → client)
```json
{
  "v": 1,
  "t": "presence.snapshot",
  "id": "s10",
  "reply_to": "c10",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "users": [
      { "user_id": "u_1", "handle": "a", "online": true, "rooms": ["r_lobby"] },
      { "user_id": "u_2", "handle": "b", "online": false, "rooms": [] }
    ]
  }
}
```

presence.event (server → client)
```json
{
  "v": 1,
  "t": "presence.event",
  "id": "s11",
  "ok": true,
  "server_ts": 1730000000555,
  "body": {
    "kind": "online|offline|join_room|leave_room",
    "user_id": "u_2",
    "room_id": "r_lobby",
    "meta": {}
  }
}
```

## Rooms & groups

Room types:
- public room: discoverable, joinable by any authenticated user
- group: ad-hoc, invite-based membership; not discoverable

room.list (client → server)

```json
{
  "v": 1,
  "t": "room.list",
  "id": "c20",
  "ts": 1730000000000,
  "body": {}
}
```

room.list_result (server → client)
```json
{
  "v": 1,
  "t": "room.list_result",
  "id": "s20",
  "reply_to": "c20",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "rooms": [
      { "room_id": "r_lobby", "name": "Lobby", "kind": "public", "member_count": 4 },
      { "room_id": "g_abc", "name": "Raid Team", "kind": "group", "member_count": 5 }
    ]
  }
}
```

room.create (client → server)
```json
{
  "v": 1,
  "t": "room.create",
  "id": "c21",
  "ts": 1730000000000,
  "body": {
    "kind": "public|group",
    "name": "string",
    "topic": "optional",
    "visibility": "discoverable|hidden" 
  }
}
```

Notes:
- visibility applies mainly to group (default hidden).

room.created (server → client)
```json
{
  "v": 1,
  "t": "room.created",
  "id": "s21",
  "reply_to": "c21",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room": { "room_id": "g_xyz", "kind": "group", "name": "Raid Team", "topic": null }
  }
}
```

room.join / room.leave (client → server)
```json
{
  "v": 1,
  "t": "room.join",
  "id": "c22",
  "ts": 1730000000000,
  "body": { "room_id": "r_lobby" }
}
```

```json
{
  "v": 1,
  "t": "room.leave",
  "id": "c23",
  "ts": 1730000000000,
  "body": { "room_id": "r_lobby" }
}
```

room.member_event (server → client)
```json
{
  "v": 1,
  "t": "room.member_event",
  "id": "s23",
  "ok": true,
  "server_ts": 1730000000456,
  "body": {
    "room_id": "r_lobby",
    "kind": "join|leave|kick|ban",
    "actor_user_id": "u_admin",
    "target_user_id": "u_2"
  }
}
```

room.invite_create (client → server) — group only

```json
{
  "v": 1,
  "t": "room.invite_create",
  "id": "c24",
  "ts": 1730000000000,
  "body": {
    "room_id": "g_xyz",
    "ttl_ms": 86400000,
    "max_uses": 1
  }
}
```

room.invite (server → client)
```json
{
  "v": 1,
  "t": "room.invite",
  "id": "s24",
  "reply_to": "c24",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room_id": "g_xyz",
    "invite_token": "string",
    "expires_at": 1730086400000,
    "max_uses": 1
  }
}
```

room.invite_redeem (client → server)

```json
{
  "v": 1,
  "t": "room.invite_redeem",
  "id": "c25",
  "ts": 1730000000000,
  "body": {
    "invite_token": "string"
  }
}
```

room.invite_redeem_ack (server → client)
```json
{
  "v": 1,
  "t": "room.invite_redeem_ack",
  "id": "s25",
  "reply_to": "c25",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room_id": "g_xyz"
  }
}
```

## Messaging (events + store-and-forward)

Messages are appended to an event log server-side.
Clients should support offline queueing and retries.

msg.send (client → server)

```json
{
  "v": 1,
  "t": "msg.send",
  "id": "c30",
  "ts": 1730000000000,
  "body": {
    "room_id": "r_lobby",
    "client_msg_id": "m_local_123",
    "text": "hello",
    "attachments": [],
    "mentions": ["u_2"]
  }
}
```

Constraints:
- Server enforces max bytes (see hello_ack limits)
- No HTML; treat as plain text
- Attachments are vNext (or small files only)

msg.ack (server → client)

Confirms persistence and assigns authoritative message ID.
```json
{
  "v": 1,
  "t": "msg.ack",
  "id": "s30",
  "reply_to": "c30",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room_id": "r_lobby",
    "client_msg_id": "m_local_123",
    "msg_id": "m_987",
    "seq": 1042
  }
}
```
msg.event (server → clients)

Broadcasted to members (including sender).
```json
{
  "v": 1,
  "t": "msg.event",
  "id": "s31",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room_id": "r_lobby",
    "msg": {
      "msg_id": "m_987",
      "seq": 1042,
      "user_id": "u_123",
      "ts": 1730000000000,
      "text": "hello"
    }
  }
}
```


msg.list (client → server)

Fetch history. Supports store-and-forward and catch-up.
```json
{
  "v": 1,
  "t": "msg.list",
  "id": "c31",
  "ts": 1730000000000,
  "body": {
    "room_id": "r_lobby",
    "after_seq": 1000,
    "limit": 200
  }
}
```

msg.list_result (server → client)
```json
{
  "v": 1,
  "t": "msg.list_result",
  "id": "s32",
  "reply_to": "c31",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room_id": "r_lobby",
    "messages": [
      { "msg_id": "m_981", "seq": 1001, "user_id": "u_2", "ts": 1730000000000, "text": "..." }
    ],
    "next_after_seq": 1042
  }
}
```

msg.read (client → server) — receipts

Optional v0 (useful for visibility).
```json
{
  "v": 1,
  "t": "msg.read",
  "id": "c32",
  "ts": 1730000000000,
  "body": {
    "room_id": "r_lobby",
    "up_to_seq": 1042
  }
}
```

msg.read_event (server → clients)
```json
{
  "v": 1,
  "t": "msg.read_event",
  "id": "s33",
  "ok": true,
  "server_ts": 1730000000456,
  "body": {
    "room_id": "r_lobby",
    "user_id": "u_123",
    "up_to_seq": 1042
  }
}
```

## Search

Use SQLite FTS in server if possible.

search.query (client → server)
```json
{
  "v": 1,
  "t": "search.query",
  "id": "c40",
  "ts": 1730000000000,
  "body": {
    "scope": { "kind": "room", "room_id": "r_lobby" },
    "q": "error timeout",
    "limit": 50
  }
}
```

search.result (server → client)
```json
{
  "v": 1,
  "t": "search.result",
  "id": "s40",
  "reply_to": "c40",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "hits": [
      {
        "room_id": "r_lobby",
        "msg_id": "m_987",
        "seq": 1042,
        "user_id": "u_123",
        "ts": 1730000000000,
        "snippet": "…error…timeout…"
      }
    ]
  }
}
```

## WebRTC signaling (required central component)

Signaling messages are exchanged via Hubot WS. Hubot does not forward media; it only coordinates.

Concepts:
- call_id: a call session tied to a room/group
- peer_id: a stable identifier for a user device/connection (server assigned)
- publisher: someone sending a stream (camera, mic, screen)
- Multiple streams per publisher allowed

rtc.call_create (client → server)

Create a call session in a room. Server becomes rendezvous point.
```json
{
  "v": 1,
  "t": "rtc.call_create",
  "id": "c50",
  "ts": 1730000000000,
  "body": {
    "room_id": "r_lobby",
    "kind": "mesh",
    "media": { "audio": true, "video": true }
  }
}
```

rtc.call (server → client)
```json
{
  "v": 1,
  "t": "rtc.call",
  "id": "s50",
  "reply_to": "c50",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "call_id": "call_123",
    "room_id": "r_lobby",
    "ice": {
      "stun_urls": ["stun:stun.l.google.com:19302"],
      "turn_urls": [],
      "turn_username": null,
      "turn_credential": null
    },
    "topology": "mesh"
  }
}
```

Notes:
- TURN is optional. If configured, server provides credentials here.
- If not configured, LAN / friendly NAT works best.

rtc.join (client → server)

Join an existing call. Server returns current participants.

```json
{
  "v": 1,
  "t": "rtc.join",
  "id": "c51",
  "ts": 1730000000000,
  "body": {
    "call_id": "call_123",
    "peer_meta": {
      "device": "MacBook",
      "capabilities": { "screen": true }
    }
  }
}
```

rtc.participants (server → client)
```json
{
  "v": 1,
  "t": "rtc.participants",
  "id": "s51",
  "reply_to": "c51",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "call_id": "call_123",
    "self_peer_id": "p0",
    "peers": [
      { "peer_id": "p1", "user_id": "u_1" },
      { "peer_id": "p2", "user_id": "u_2" }
    ]
  }
}
```

rtc.call_event (server → client)

Broadcasted to room members when a call is created.
```json
{
  "v": 1,
  "t": "rtc.call_event",
  "id": "s55",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "room_id": "r_lobby",
    "call_id": "call_123",
    "event": "created"
  }
}
```

rtc.peer_event (server → client)

Broadcasted to call participants when a peer joins or leaves.
```json
{
  "v": 1,
  "t": "rtc.peer_event",
  "id": "s56",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "call_id": "call_123",
    "kind": "join",
    "peer": { "peer_id": "p3", "user_id": "u_3" }
  }
}
```
rtc.offer / rtc.answer (client → server)

Client sends an SDP offer to a specific peer (mesh).
```json
{
  "v": 1,
  "t": "rtc.offer",
  "id": "c52",
  "ts": 1730000000000,
  "body": {
    "call_id": "call_123",
    "to_peer_id": "p2",
    "from_peer_id": "p1",
    "sdp": "v=0..."
  }
}
```

Server validates membership and forwards as an event:
```json
{
  "v": 1,
  "t": "rtc.offer_event",
  "id": "s52",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "call_id": "call_123",
    "to_peer_id": "p2",
    "from_peer_id": "p1",
    "sdp": "v=0..."
  }
}
```

Answer similarly:
- rtc.answer → rtc.answer_event

rtc.ice (client → server)

ICE candidate forwarding.

```json
{
  "v": 1,
  "t": "rtc.ice",
  "id": "c53",
  "ts": 1730000000000,
  "body": {
    "call_id": "call_123",
    "to_peer_id": "p2",
    "from_peer_id": "p1",
    "candidate": {
      "candidate": "candidate:...",
      "sdpMid": "0",
      "sdpMLineIndex": 0
    }
  }
}
```

Server forwards rtc.ice_event.

Streams metadata (multiple concurrent streams)

Each peer may publish multiple streams identified by stream_id:
	•	cam
	•	screen
	•	window
	•	app
(or arbitrary string with constraints)

rtc.stream_publish (client → server)
```json
{
  "v": 1,
  "t": "rtc.stream_publish",
  "id": "c54",
  "ts": 1730000000000,
  "body": {
    "call_id": "call_123",
    "peer_id": "p1",
    "stream": {
      "stream_id": "screen_1",
      "kind": "screen",
      "label": "Joey’s Screen",
      "tracks": { "audio": false, "video": true }
    }
  }
}
```
Server broadcasts:
```json
{
  "v": 1,
  "t": "rtc.stream_event",
  "id": "s54",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "call_id": "call_123",
    "peer_id": "p1",
    "event": "published|unpublished|updated",
    "stream": {
      "stream_id": "screen_1",
      "kind": "screen",
      "label": "Joey’s Screen",
      "tracks": { "audio": false, "video": true }
    }
  }
}
```

rtc.leave / rtc.end_call
- rtc.leave: peer leaves
- rtc.end_call: room owner/admin ends the call

rtc.call_end (server → client)
```json
{
  "v": 1,
  "t": "rtc.call_end",
  "id": "s57",
  "ok": true,
  "server_ts": 1730000000123,
  "body": {
    "call_id": "call_123",
    "room_id": "r_lobby"
  }
}
```


## Hubot as participant (bot events)

Clients can treat Hubot as a user user_id = u_hubot with special capabilities.

bot.command (client → server)

Sends a command intended for Hubot scripts (server validates authorization).
```json
{
  "v": 1,
  "t": "bot.command",
  "id": "c60",
  "ts": 1730000000000,
  "body": {
    "room_id": "r_lobby",
    "command": "help",
    "args": "optional string"
  }
}
```

Server emits it into Hubot’s command registry and returns:

```json
{
  "v": 1,
  "t": "bot.command_ack",
  "id": "s60",
  "reply_to": "c60",
  "ok": true,
  "server_ts": 1730000000123,
  "body": { "queued": true }
}
```

Hubot output should come back as normal msg.event from u_hubot.

## Admin protocol (super rights)

admin.invite_create (client → server)

Create invite for new users.

```json
{
  "v": 1,
  "t": "admin.invite_create",
  "id": "c70",
  "ts": 1730000000000,
  "body": { "ttl_ms": 86400000, "max_uses": 1, "note": "Raid night" }
}
```

admin.invite (server → client)
```json
{
  "v": 1,
  "t": "admin.invite",
  "id": "s70",
  "reply_to": "c70",
  "ok": true,
  "server_ts": 1730000000123,
  "body": { "invite_token": "string", "expires_at": 1730086400000, "max_uses": 1 }
}
```

admin.export / admin.import (v0 optional)
- export SQLite DB (and optionally attachments) — likely via HTTP download route instead of WS payload.


## Validation rules (minimum required)

Server MUST reject if:
- v != 1
- missing t, id, ts, or body
- id too long (>128) or not string
- body contains unexpected fields for sensitive endpoints (auth/admin)
- not authenticated for protected message types
- user not member of target room/group
- signaling payload exceeds max size
- rate limits exceeded

Client SHOULD:
- retry idempotent requests on transient errors
- queue outgoing messages when offline and replay on reconnect
- reconcile with msg.ack + authoritative seq

## While keeping protocol stable
- Attachments via WebRTC DataChannel (preferred) with Hubot fallback store-and-forward
- E2EE for text messages (room key rotation; forward secrecy)
- Partial message edits/deletes (append-only event log with tombstones)
- Reactions / threads (events)
- Push-to-talk events + voice activity indicators

